# CPP_SimpleContainers

## Введение

В рамках данного проекта написана собственная библиотека `containers.h`, реализующая стандартные контейнерные классы языка С++: `stack` (стек), `queue` (очередь) и `list` (список). Реализация предоставляет весь набор стандартных методов и атрибутов для работы с элементами, проверкой заполненности контейнера и итерирования.

## Информация

Каждый вид контейнеров предоставляет пользователю следующие методы:

- стандартные конструкторы (конструктор по умолчанию, конструктор копирования, конструктор перемещения, конструктор со списком инициализации, см. материалы);

- методы доступа к элементам контейнера (например, осуществление доступа к элементу с индексом i);

- методы проверки наполненности контейнера (например, количество элементов в контейнере, проверка на пустоту контейнера);

- методы изменения контейнера (удаление и добавление новых элементов, очистка контейнера);

- методы для работы с итератором контейнера `list` (список)

>Итераторы обеспечивают доступ к элементам контейнера. Для каждого контейнера конкретный тип итератора будет отличаться. Это связано с различным видом организации наборов объектов в контейнерных классах, а также с фактической реализацией контейнера. Итераторы реализуются в таком виде, чтобы они работали схожим образом с указателем на элемент массива языка Си. Именно такой подход через использование итераторов и позволяет взаимодействовать с любыми контейнерами одинаковым образом. Контейнеры предоставляют через методы `begin()` и `end()` итераторы, которые указывают на первый и следующий после последнего элементы контейнера соответственно.

Над итератором `iter` определены следующие операции:

- `*iter`: получение элемента, на который указывает итератор;

- `++iter`: перемещение итератора вперед для обращения к следующему элементу;

- `--iter`: перемещение итератора назад для обращения к предыдущему элементу;

- `iter1 == iter2`: два итератора равны, если они указывают на один и тот же элемент;

- `iter1 != iter2`: два итератора не равны, если они указывают на разные элементы.

Помимо особой организации объектов и предоставления необходимых методов, реализация контейнерных классов требует шаблонизации объектов. 

## Реализация библиотеки `containers.h`

- Программа разработана на языке C++ с использованием компилятора gcc
- Код программы находится в папке src
- Классы реализованы шаблонными
- Классы реализованы внутри пространства имен `m3mpm`
- Реализация покрытие unit-тестами методов контейнерных классов c помощью библиотеки GTest
- Решение оформлено в виде заголовочного файла `containers.h`, который включает в себя другие заголовочные файлы с реализациями необходимых контейнеров: `stack.h`, `queue.h` и `list.h`. 
- Реализован Makefile для тестов написанной библиотеки с целями all clean test gcov_report debug check_leaks.
- За основу взята классическая реализация контейнеров

### Дополнительно. Реализация модифицированных методов `emplace`

Классы дополнены соответствующими методами, согласно таблице:

| Modifiers      | Definition                                      | Containers |
|----------------|-------------------------------------------------| -------------------------------------------|
| `iterator emplace(const_iterator pos, Args&&... args)`          | inserts new elements into the container directly before `pos`  | List |
| `void emplace_back(Args&&... args)`          | appends new elements to the end of the container  | List  |
| `void emplace_front(Args&&... args)`          | appends new elements to the top of the container  | List |

*Внимание*: В качестве аргументов передаются уже созданные элементы, которые необходимо вставить в соответствующий контейнер.

*Внимание*: Каждый из этих методов использует конструкцию Args&&... args - Parameter pack. Эта конструкция позволяет передавать переменное число параметров в функцию или метод. То есть при вызове метода, определенного как `iterator emplace(const_iterator pos, Args&&... args)`, можно написать как `emplace(pos, arg1, arg2)`, так и `emplace(pos, arg1, arg2, arg3)`.

## Запуск тестов и формирование отчета о покрытие unit-тестами

- Перейдите в папку src/, в данной папке находиться Makefile
- Для запуска тестов необходимо набрать следующую команду: *make test*
- Для создания отчета о покрытие unit-тестами необходимо набрать следующую команду: *make gcov_report* Для этого необходимо установить на ПК утилиту gcov и lcov
- Для очистки от всех временных файлов наберите следующую команду: *make clean*
